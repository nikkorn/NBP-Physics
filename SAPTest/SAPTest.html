<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>The HTML5 Herald</title>
  <meta name="description" content="The HTML5 Herald">
  <meta name="author" content="SitePoint">
</head>

<body></body>
<script>
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");

  canvas.width = 500;
  canvas.height = 500;
  canvas.style.border = "thin solid black";
  canvas.style.background = "#FFFFF";

  const colours = {
    "red": "#b50327",
    "green": "#027a16",
    "blue": "#0574b5",
    "orange": "#c67d07",
    "purple": "#650289",
    "pink": "#e58bd9"
  };

  /**
   * Create an AABB at x/y with the width/height. 
   */
  function createAABB(name, x, y, width, height)
  {
    return { name, x, y, width, height, halfWidth: width / 2, halfHeight: height / 2 };
  }

  function findAxisIntersections(boxes, getAxis, getSize) 
  {
    // Sort items by left-most min x (just left edge) into sortedList.
    // Create active list and add first (left-most) sorted item to it.
    // For each next item (N) in the sorted axis list:
    // - For each item (E) in the active list:
    // - - If N.x > (E.x + E.width) : Remove E from the active list.
    // - - Else                     : Report potential collision between N and E before adding N to the active list.

    // Do nothing if there are no boxes.
    if (!boxes.length) { return; }

    // Sort the boxes left-to-right.
    boxes.sort((a, b) => getAxis(a) - getAxis(b));

    // Create the active list, adding the left-most box.
    const activeList = [boxes[0]];

    // Store a list of potential colliding pairs. 
    const potential = {};

    // For each next item (N) in the sorted axis list.
    for (var boxIndex = 1; boxIndex < boxes.length; boxIndex++) {
      // Get the next box along.
      const next = boxes[boxIndex];

      if (!potential[next.name]) {
        potential[next.name] = [];
      }

      let activeIndex = activeList.length;

      while (activeIndex) {
        // Get the current active item.
        const active = activeList[--activeIndex];

        if (getAxis(next) > (getAxis(active) + getSize(active))) {
          activeList.splice(activeIndex, 1);
        }
      }

      activeList.forEach(active => {
        if (!potential[active.name]) {
          potential[active.name] = [];
        }
        potential[active.name].push(next.name);
        potential[next.name].push(active.name);
      });

      activeList.push(next);
    }

    // Return the list of potential colliding pairs.
    return potential;
  }

  function drawBoxes(boxes) 
  {
    for (var i = 0; i < boxes.length; i++)
    {
      ctx.fillStyle = colours[boxes[i].name];
      ctx.fillRect(boxes[i].x, boxes[i].y, boxes[i].width, boxes[i].height);
    }
  }

  function go() {
    // Create the boxes in the world.
    var boxes = [
      createAABB("red", 150, 120, 150, 10),
      createAABB("green", 50, 220, 100, 100),
      createAABB("orange", 230, 250, 100, 120),
      createAABB("blue", 200, 100, 50, 100),
      createAABB("purple", 120, 400, 300, 80),
      createAABB("pink", 450, 200, 10, 200)
    ];

    // Find potential collisions on the X axis.
    const xIntersections = findAxisIntersections(boxes, (box) => box.x, (box) => box.width);

    // Find potential collisions on the Y axis.
    const yIntersections = findAxisIntersections(boxes, (box) => box.y, (box) => box.height);

    // We should have potential colliding pairs.
    console.log({ xIntersections, yIntersections });

    // Draw the boxes.
    drawBoxes(boxes);
  }

  // Do the stuff!!!! 
  go();
   
  document.body.appendChild(canvas);
</script>
</html>