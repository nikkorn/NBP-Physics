<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>The HTML5 Herald</title>
  <meta name="description" content="The HTML5 Herald">
  <meta name="author" content="SitePoint">
</head>

<body></body>
<script>
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");

  canvas.width = 1000;
  canvas.height = 1000;
  canvas.style.border = "thin solid black";
  canvas.style.background = "#FFFFF";

  const colours = {
    "red": "#b50327",
    "green": "#027a16",
    "blue": "#0574b5",
    "orange": "#c67d07",
    "purple": "#650289",
    "pink": "#e58bd9"
  };

  /**
   * Make a random id.
   */
   function makeId() {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for (var i = 0; i < 10; i++)
      text += possible.charAt(Math.floor(Math.random() * possible.length));

    return text;
  }

  /**
   * Create an AABB at x/y with the width/height. 
   */
  function createAABB(name, x, y, width, height)
  {
    return { name, x, y, width, height, halfWidth: width / 2, halfHeight: height / 2 };
  }

  /**
   * Create a random bunch of boxes. 
   */
  function generateAABBs(count, minPos, maxPos, minSize, maxSize) {
    const boxes = [];
    for(var index = 0; index < count; index++) {
      const id     = makeId();
      const x      = minPos + Math.floor(Math.random() * (maxPos - minPos));
      const y      = minPos + Math.floor(Math.random() * (maxPos - minPos));
      const width  = minSize + Math.floor(Math.random() * (maxSize - minSize));
      const height = minSize + Math.floor(Math.random() * (maxSize - minSize));
      boxes.push(createAABB(id, x, y, width, height));
    }
    return boxes;
  }

  /**
   * Find intersection for boxes on an axis.
   */
  function findAxisIntersections(boxes, getAxis, getSize) 
  {
    // Sort items by left-most min x (just left edge) into sortedList.
    // Create active list and add first (left-most) sorted item to it.
    // For each next item (N) in the sorted axis list:
    // - For each item (E) in the active list:
    // - - If N.x > (E.x + E.width) : Remove E from the active list.
    // - - Else                     : Report potential collision between N and E before adding N to the active list.

    // Do nothing if there are no boxes.
    if (!boxes.length) { return; }

    // Sort the boxes left-to-right.
    boxes.sort((a, b) => getAxis(a) - getAxis(b));

    // Create the active list, adding the left-most box.
    const activeList = [boxes[0]];

    // Store a list of potential colliding pairs. 
    const potential = {};

    // For each next item (N) in the sorted axis list.
    for (var boxIndex = 1; boxIndex < boxes.length; boxIndex++) {
      // Get the next box along.
      const next = boxes[boxIndex];

      if (!potential[next.name]) {
        potential[next.name] = [];
      }

      let activeIndex = activeList.length;

      while (activeIndex) {
        // Get the current active item.
        const active = activeList[--activeIndex];

        if (getAxis(next) > (getAxis(active) + getSize(active))) {
          activeList.splice(activeIndex, 1);
        }
      }

      activeList.forEach(active => {
        if (!potential[active.name]) {
          potential[active.name] = [];
        }
        potential[active.name].push(next.name);
        potential[next.name].push(active.name);
      });

      activeList.push(next);
    }

    // Return the list of potential colliding pairs.
    return potential;
  }

  function drawBoxes(boxes, intersections) 
  {
    const boxHasCollision = (box) => intersections.some((intersection) => intersection[0] === box.name);

    for (var i = 0; i < boxes.length; i++)
    {
      ctx.fillStyle = boxHasCollision(boxes[i]) ? "#b50327" : "#0574b5";
      ctx.fillRect(boxes[i].x, boxes[i].y, boxes[i].width, boxes[i].height);
    }
  }

  /**
   * Get an array of every value common to every array within the specified array.
   */
  function getCommonElements(arrays) {
    if (arrays.length <= 0) {
      return [];
    } else if (arrays.length === 1) {
      // There is is only one array so the values within it are common across all.
      return arrays[0];
    } else {
      // There are multiple arrays, we need to find the values common to all.
      return arrays[0].filter((value) => arrays.every((array) => array.indexOf(value) !== -1));
    }
  }

  function go() {
    // Create the boxes in the world.
    var boxes = generateAABBs(1000, 10, 980, 5, 20);

    // Get the start time so we can see how long it takes to do the deed.
    const startTime = new Date().getTime();

    // Find potential collisions on the X axis.
    const xIntersections = findAxisIntersections(boxes, (box) => box.x, (box) => box.width);

    // Find potential collisions on the Y axis.
    const yIntersections = findAxisIntersections(boxes, (box) => box.y, (box) => box.height);

    const intersections = boxes
      .map((box) => ([ box.name, getCommonElements([ xIntersections[box.name], yIntersections[box.name]]) ]))
      .filter((intersection) => intersection[1].length);
		
		// Log the details to the console.
    console.log("Found " + intersections.length + " intersections in " + boxes.length + " boxes, took " + (new Date().getTime() - startTime) + "ms");

    // Draw the boxes.
    drawBoxes(boxes, intersections);
  }

  // Do the stuff!!!! 
  go();
   
  document.body.appendChild(canvas);
</script>
</html>